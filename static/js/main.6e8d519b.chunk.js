(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{14:function(e,n,t){},15:function(e,n,t){},17:function(e,n,t){"use strict";t.r(n);var i=t(0),r=t.n(i),o=t(6),a=t.n(o),s=(t(14),t(15),t(8)),c=(t(4),t(1));t(7);var u=t(3),l=t(2),h="#define GLSLIFY 1\nvarying vec4 vUv;\n\nfloat magnitude(vec3 pos) {\n  return pow(pow(pos.x, 2.0) + pow(pos.y, 2.0) + pow(pos.z, 2.0), 0.5);\n}\nvoid main() {\n  vUv = vec4(position, 1.0);\n\n  vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n  gl_Position = projectionMatrix * modelViewPosition;\n}\n",v=function(e){var n=e.geometry,t=void 0===n?new c.i(10,10,10):n,i=e.uniforms,r=void 0===i?null:i,o=e.vertexShader,a=void 0===o?h:o,s=e.fragmentShader,u=void 0===s?"#define GLSLIFY 1\nuniform sampler2D tAudioData;\nvarying vec4 vUv;\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvoid main() {\n  float M_PI = 3.1415926535897932384626433832795;\n  float f =  texture2D( tAudioData, vUv.xy).g;\n  float radius = 0.5;\n\n  vec3 backgroundColor = vec3(1.0, 0.0 , 0.0);\n  float red  = min(vUv.y / 4.0, 1.0);\n  vec3 color = vec3( 0.0, 0.0, 0.0);\n  float i = step(sin(vUv.x + vUv.y + vUv.z), f) ;\n  gl_FragColor = vec4( mix(backgroundColor, color, i), 1.0 );\n  \n  //gl_FragColor = vec4(vec3(1,0,0), 1.0);\n  //gl_FragColor.a = f;\n}\n":s;return new c.g(t,function(e){var n=e.uniforms,t=void 0===n?null:n,i=e.vertexShader,r=e.fragmentShader;return new c.k({uniforms:t,vertexShader:i,fragmentShader:r,transparent:!0,opacity:.5,side:c.e})}({uniforms:r,vertexShader:a,fragmentShader:u}))},m=function(e){return 0};function d(e){switch(e){case"CIRCLEXY_SINEZ":return{x:function(e){return-e.y},y:function(e){return e.x},z:function(e){var n=function(e){var n=e.pos1,t=void 0===n?{x:0,y:0,z:0}:n,i=e.pos2,r=void 0===i?{x:0,y:0,z:0}:i;return Math.sqrt(Object.keys(t).reduce((function(e,n){return e+Math.pow(t[n]-r[n],2)}),0))}({pos1:e}),t=e.y/n;return Math.cos(Math.asin(t))/Math.sqrt(1-Math.pow(t,2))*e.x}};case"CIRCLEXZ":return{x:function(e){return e.z},z:function(e){return-e.x}};case"RANDOM":return{x:function(e){return e.x*e.z},y:function(e){return-e.z},z:function(e){return-e.z}};case"LORENZ":return{x:function(e){return 28*(e.y-e.x)},y:function(e){return e.x*(28-e.z)-e.y},z:function(e){return e.x*e.y-8/3*e.z}};default:return{x:m,y:m,z:m}}}var f=function(){function e(n){Object(u.a)(this,e);var t=d(n),i=t.x,r=void 0===i?m:i,o=t.y,a=void 0===o?m:o,s=t.z,c=void 0===s?m:s;this.x=r,this.y=a,this.z=c}return Object(l.a)(e,[{key:"flow",value:function(e){var n=e.position,t=e.stepSize,i=void 0===t?.01:t;return{x:n.x+this.x(n)*i,y:n.y+this.y(n)*i,z:n.z+this.z(n)*i}}}]),e}(),p=function(){function e(n){var t=n.geometry,i=n.name,r=n.position,o=void 0===r?{x:0,y:0,z:0}:r,a=n.vertexShader,s=void 0===a?h:a,c=n.fragmentShader,l=n.vectorFieldConfig;Object(u.a)(this,e),this.geometry=t,this.name=i,this.position=o,this.vertexShader=s,this.fragmentShader=c,this.vectorField=new f(l)}return Object(l.a)(e,[{key:"initMesh",value:function(e){var n=v({uniforms:e,geometry:this.geometry,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader});return n.name=this.name,n.position.set(this.position.x,this.position.y,this.position.z),this.mesh=n,n}},{key:"animate",value:function(e){var n=this.mesh.position,t=this.vectorField.flow({position:n,stepSize:e});null!=this.mesh.material.uniforms&&(this.mesh.material.uniforms.u_time.value+=e),this.mesh.position.set(t.x,t.y,t.z)}}]),e}();function _(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";switch(e){case"SQUARE":return[0,1,2,3].map((function(e){var n=2*Math.PI*e/4;return{x:Math.cos(n),y:Math.sin(n),z:0}}));case"SQUARE_SUSPENSION":return[0,1,2,3,4,5].map((function(e){return{x:e%3==0?Math.pow(-1,e%2):0,y:e%3==1?Math.pow(-1,e%2):0,z:e%3==2?Math.pow(-1,e%2):0}}));default:return[{x:0,y:0,z:100}]}}var y=function(){function e(n){var t=n.name,i=n.focus,r=void 0===i?{x:0,y:0,z:0}:i,o=n.vectorField,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5;Object(u.a)(this,e);var s=_(t);this.config=t,this.dist=a,this.positions=s.map((function(e){return{x:a*e.x+r.x,y:a*e.y+r.y,z:a*e.z+r.z}})),this.focus=r,this.number=0,this.vectorField=new f(o)}return Object(l.a)(e,[{key:"flow",value:function(e){var n=this.focus,t=this.vectorField.flow({position:n,stepSize:e});this.positions=this.positions.map((function(e){return{x:e.x+t.x-n.x,y:e.y+t.y-n.y,z:e.z+t.z-n.z}})),this.focus=t}},{key:"resetFocus",value:function(e){var n=this,t=_(this.config);this.positions=t.map((function(t){return{x:n.dist*t.x+e.x,y:n.dist*t.y+e.y,z:n.dist*t.z+e.z}})),this.focus=e}},{key:"follow",value:function(e,n){this.resetFocus(e),this.vectorField=n}},{key:"getActivePosition",value:function(){return this.positions[this.number]}},{key:"switch",value:function(e){this.number=e}},{key:"next",value:function(){this.number=(this.number+1)%this.positions.length}},{key:"setVectorField",value:function(e){this.vectorField=e}}]),e}(),x=function(){function e(n){var t=n.width,i=n.height,r=n.models;Object(u.a)(this,e),this.scene=new c.j,this.camera=new c.h(75,t/i,.1,1e3),this.renderer=new c.o({antialias:!0}),this.renderer.setClearColor("#000000"),this.renderer.setSize(t,i),this.models=r.map((function(e){return new p(e)})),this.cameraGroup=new y({name:"BASIC",focus:{x:10,y:1,z:10},vectorField:"ZERO"},0),this.stepSize=.001,this.paused=!0,console.log(this.scene)}return Object(l.a)(e,[{key:"cameraAnimate",value:function(e){var n=this.cameraGroup.getActivePosition(),t=n.x,i=n.y,r=n.z;this.camera.position.z=r,this.camera.position.x=t,this.camera.position.y=i,this.camera.lookAt(this.cameraGroup.focus.x,this.cameraGroup.focus.y,this.cameraGroup.focus.z),this.camera.up.set(0,0,1),this.cameraGroup.flow(e)}},{key:"renderScene",value:function(){var e=this;this.cameraAnimate(),this.models.forEach((function(n){return n.animate(e.stepSize)})),this.renderer.render(this.scene,this.camera)}},{key:"play",value:function(){}},{key:"pause",value:function(){this.paused=!0}},{key:"add",value:function(e){var n=this;console.log("adding objects"),e.forEach((function(e){n.scene.add(e)}))}},{key:"loadMeshes",value:function(e){var n=this;this.models.forEach((function(t){switch(t.geometry.type){case"PlaneGeometry":e.u_resolution=new c.m(new c.n(t.geometry.parameters.width,t.geometry.parameters.height))}console.log(t.geometry.parameters.width);var i=t.initMesh(e);n.scene.add(i)}))}},{key:"handleResize",value:function(e,n){this.renderer.setSize(e,n),this.camera.aspect=e/n,this.camera.updateProjectionMatrix(),this.renderScene()}}]),e}(),g=function(e,n){var t=e.current.clientWidth,i=e.current.clientHeight,r=[],o={geometry:new c.l(100,102,160),name:"background",fragmentShader:n,position:{x:0,y:0,z:0}};r.push(o);var a=new x({width:t,height:i,models:r});return a.loadMeshes({u_time:{value:0}}),a},w=function(e){var n=Object(i.useRef)(null),t=Object(i.useState)(!0),o=Object(s.a)(t,2),a=o[0],c=o[1],u=Object(i.useRef)(null),l=e.backgroundShader;return Object(i.useEffect)((function(){var e,t=g(n,l),i=function(){t.handleResize(n.current.clientWidth,n.current.clientHeight)},r=function n(){t.renderScene(),e=window.requestAnimationFrame(n)},o=function(){cancelAnimationFrame(e),e=null};return n.current.appendChild(t.renderer.domElement),window.addEventListener("resize",i),u.current={start:function(){e||(t.play(),e=requestAnimationFrame(r))},stop:o},function(){o(),window.removeEventListener("resize",i)}}),[]),Object(i.useEffect)((function(){try{a?u.current.start():u.current.stop()}catch(e){console.log(e)}}),[a]),r.a.createElement("div",{className:"three-container",ref:n,onClick:function(){return c(!a)}})};t(16);var q=function(){return r.a.createElement("div",null,r.a.createElement("div",{className:"content"},r.a.createElement("section",{className:"hero"},r.a.createElement("div",{className:"hero-body"},r.a.createElement("p",{className:"title"},"Antony Della Vecchia"),r.a.createElement("p",{className:"subtitle"},r.a.createElement("a",{href:"https://github.com/antonydellavecchia"},"github")))),r.a.createElement("section",{className:"section "},r.a.createElement("h1",{className:"title"},"Section"),r.a.createElement("h2",{className:"subtitle"},"A simple container to divide your page into ",r.a.createElement("strong",null,"sections"),", like the one you're currently reading."))),r.a.createElement(w,{backgroundShader:"#ifdef GL_ES\nprecision highp float;\n#define GLSLIFY 1\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\nvarying vec4 vUv;\n\nfloat weighted_dot(vec3 p, vec3 q) {\n  float ratio = u_resolution.x / u_resolution.y;\n  return pow(ratio, 2.0) * p.x * q.x + p.y * q.y + p.z * q.z;\n}\n\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n  float f_0 = p.y - p.x * p.x;\n  float f_1 = p.z - pow(p.y, 3.0);\n  //return max(f_0, f_1);\n  return sqrt(weighted_dot(p - c, p - c)) - r;\n}\n\nfloat map_the_world(in vec3 p)\n{\n    float sphere_0 = distance_from_sphere(p, vec3(0.0), 1.0);\n\n    // Later we might have sphere_1, sphere_2, cube_3, etc...\n\n    return sphere_0;\n}\n\nvec3 calculate_normal(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = map_the_world(p + small_step.xyy) - map_the_world(p - small_step.xyy);\n    float gradient_y = map_the_world(p + small_step.yxy) - map_the_world(p - small_step.yxy);\n    float gradient_z = map_the_world(p + small_step.yyx) - map_the_world(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 ray_march(in vec3 ro, in vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 32;\n    const float MINIMUM_HIT_DISTANCE = 1.0;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n    vec3 color = vec3(0.0, 0.0, 1.0);\n    \n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Calculate our current position along the ray\n        vec3 current_position = ro + total_distance_traveled * rd;\n\n        // We wrote this function earlier in the tutorial -\n        // assume that the sphere is centered at the origin\n        // and has unit radius\n        float distance_to_closest = distance_from_sphere(current_position, vec3(0.0, 0.0, 0.0), 1.0);\n\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) // hit\n        {\n\n\t  vec3 normal = calculate_normal(current_position);\n\t  vec3 light_position = vec3(2.0, -5.0 * cos(u_time), 3.0);\n\t  vec3 direction_to_light = normalize(current_position - light_position);\n\n\t  float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n\n\t  return vec3(1.0, 0.0, 0.0) * diffuse_intensity;\n        }\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE) // miss\n        {\n\t  break;\n        }\n\n        // accumulate the distance traveled thus far\n        total_distance_traveled += distance_to_closest;\n    }\n\n    // If we get here, we didn't hit anything so just\n    // return a background color (black)\n    return color;\n}\n\nvec4 quat_from_axis_angle(vec3 axis, float angle)\n{ \n  vec4 qr;\n  float half_angle = (angle * 0.5) * 3.14159 / 180.0;\n  qr.x = axis.x * sin(half_angle);\n  qr.y = axis.y * sin(half_angle);\n  qr.z = axis.z * sin(half_angle);\n  qr.w = cos(half_angle);\n  return qr;\n}\n\nvec4 quat_conj(vec4 q)\n{ \n  return vec4(-q.x, -q.y, -q.z, q.w); \n}\n\nvec4 quat_mult(vec4 q1, vec4 q2)\n{ \n  vec4 qr;\n  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n  return qr;\n}\n\nvec3 rotate_vertex_position(vec3 position, vec3 axis, float angle)\n{ \n  vec4 qr = quat_from_axis_angle(axis, angle);\n  vec4 qr_conj = quat_conj(qr);\n  vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n  \n  vec4 q_tmp = quat_mult(qr, q_pos);\n  qr = quat_mult(q_tmp, qr_conj);\n  \n  return vec3(qr.x, qr.y, qr.z);\n}\n\nfloat polynomial(vec3 normal) {\n  return pow(normal.x, 3.0) - pow(normal.y, 2.0) * normal.x + 3.0 * cos(sqrt(2.0) * u_time) *normal.z * normal.x * normal.y * 10.0 * u_time * sin(1.0);\n}\n\nvoid main() {\n  vec3 ray_origin = vec3(0.0, 0.0, 1.0);\n  vec2 uv =  gl_FragCoord.xy / u_resolution.xy;\n  vec3 P = rotate_vertex_position(normalize(vUv.xyz), vec3(0.0, cos(u_time),sin(u_time)), 10.0 * u_time);\n  vec3 color = vec3(step(abs(polynomial(P)), 0.05), step(abs(polynomial(P)), 0.05), P.z);\n  gl_FragColor = vec4(abs(color), 1.0);\n}\n"}))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));a.a.render(r.a.createElement(q,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()}))},9:function(e,n,t){e.exports=t(17)}},[[9,1,2]]]);
//# sourceMappingURL=main.6e8d519b.chunk.js.map